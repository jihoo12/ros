/***
    unsafe {
        scheduler::init();
        crate::println!("Scheduler Initialized!");

        let stack_size = 4096 * 4;
        let stack_a = allocator::alloc(stack_size) as u64;
        let stack_b = allocator::alloc(stack_size) as u64;

        scheduler::add_new_task(task_a, stack_a, stack_size);
        scheduler::add_new_task(task_b, stack_b, stack_size);
    }

    // Main Loop (Task 0)
    loop {
        crate::println!("Main Task (ID 0) yielding...");
        scheduler::switch_task();
        // Simple delay
        for _ in 0..10000000 {
            core::hint::spin_loop();
        }
    }
extern "C" fn task_a() {
    loop {
        crate::println!("Task A running");
        crate::scheduler::switch_task();
        for _ in 0..10000000 {
            core::hint::spin_loop();
        }
    }
}

extern "C" fn task_b() {
    loop {
        crate::println!("Task B running");
        crate::scheduler::switch_task();
        for _ in 0..10000000 {
            core::hint::spin_loop();
        }
    }
}
    unsafe {
        let size = 128; // 128 bytes
        let ptr = syscall(2, size, 0, 0, 0, 0, 0) as *mut u8;

        if !ptr.is_null() {
            let success_msg = "Allocated memory successfully!\n";
            syscall(
                1,
                success_msg.as_ptr() as usize,
                success_msg.len(),
                0,
                0,
                0,
                0,
            );

            // Write to it
            *ptr = b'A';
            *ptr.add(1) = b'B';
            *ptr.add(2) = b'C';
            *ptr.add(3) = 0; // null terminator if we were using it for C-string

            // Verify? We can just print saying we wrote to it.
            let write_msg = "Wrote to allocated memory.\n";
            syscall(1, write_msg.as_ptr() as usize, write_msg.len(), 0, 0, 0, 0);

            // Free it
            syscall(3, ptr as usize, 0, 0, 0, 0, 0);
            let free_msg = "Freed memory.\n";
            syscall(1, free_msg.as_ptr() as usize, free_msg.len(), 0, 0, 0, 0);
        } else {
            let fail_msg = "Allocation failed!\n";
            syscall(1, fail_msg.as_ptr() as usize, fail_msg.len(), 0, 0, 0, 0);
        }
    }
    test done!
    #[unsafe(no_mangle)]
pub unsafe extern "sysv64" fn user_task_b() {
    let msg = "User Task B: Started! Yielding back to A...\n";
    unsafe {
        syscall(1, msg.as_ptr() as usize, msg.len(), 0, 0, 0, 0);

        loop {
            let msg2 = "User Task B: Yielding back to A...\n";
            syscall(1, msg2.as_ptr() as usize, msg2.len(), 0, 0, 0, 0);

            // Switch Task
            syscall(6, 0, 0, 0, 0, 0, 0);

            // Delay
            for _ in 0..10000000 {
                core::hint::spin_loop();
            }
        }
    }
}
***/
