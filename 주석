/***
    unsafe {
        scheduler::init();
        crate::println!("Scheduler Initialized!");

        let stack_size = 4096 * 4;
        let stack_a = allocator::alloc(stack_size) as u64;
        let stack_b = allocator::alloc(stack_size) as u64;

        scheduler::add_new_task(task_a, stack_a, stack_size);
        scheduler::add_new_task(task_b, stack_b, stack_size);
    }

    // Main Loop (Task 0)
    loop {
        crate::println!("Main Task (ID 0) yielding...");
        scheduler::switch_task();
        // Simple delay
        for _ in 0..10000000 {
            core::hint::spin_loop();
        }
    }
extern "C" fn task_a() {
    loop {
        crate::println!("Task A running");
        crate::scheduler::switch_task();
        for _ in 0..10000000 {
            core::hint::spin_loop();
        }
    }
}

extern "C" fn task_b() {
    loop {
        crate::println!("Task B running");
        crate::scheduler::switch_task();
        for _ in 0..10000000 {
            core::hint::spin_loop();
        }
    }
}
    unsafe {
        let size = 128; // 128 bytes
        let ptr = syscall(2, size, 0, 0, 0, 0, 0) as *mut u8;

        if !ptr.is_null() {
            let success_msg = "Allocated memory successfully!\n";
            syscall(
                1,
                success_msg.as_ptr() as usize,
                success_msg.len(),
                0,
                0,
                0,
                0,
            );

            // Write to it
            *ptr = b'A';
            *ptr.add(1) = b'B';
            *ptr.add(2) = b'C';
            *ptr.add(3) = 0; // null terminator if we were using it for C-string

            // Verify? We can just print saying we wrote to it.
            let write_msg = "Wrote to allocated memory.\n";
            syscall(1, write_msg.as_ptr() as usize, write_msg.len(), 0, 0, 0, 0);

            // Free it
            syscall(3, ptr as usize, 0, 0, 0, 0, 0);
            let free_msg = "Freed memory.\n";
            syscall(1, free_msg.as_ptr() as usize, free_msg.len(), 0, 0, 0, 0);
        } else {
            let fail_msg = "Allocation failed!\n";
            syscall(1, fail_msg.as_ptr() as usize, fail_msg.len(), 0, 0, 0, 0);
        }
    }
    test done!
    #[unsafe(no_mangle)]
pub unsafe extern "sysv64" fn user_task_b() {
    let msg = "User Task B: Started! Yielding back to A...\n";
    unsafe {
        syscall(1, msg.as_ptr() as usize, msg.len(), 0, 0, 0, 0);

        loop {
            let msg2 = "User Task B: Yielding back to A...\n";
            syscall(1, msg2.as_ptr() as usize, msg2.len(), 0, 0, 0, 0);

            // Switch Task
            syscall(6, 0, 0, 0, 0, 0, 0);

            // Delay
            for _ in 0..10000000 {
                core::hint::spin_loop();
            }
        }
    }
}
                // Test NVMe Write
            println!("Testing NVMe Write...");
            let msg = b"Hello NVMe World!";
            let mut write_buf = [0u8; 512];
            for (i, &b) in msg.iter().enumerate() {
                write_buf[i] = b;
            }
            nvme::nvme_write(1, 0, write_buf.as_mut_ptr(), 1);
            println!("Write completed.");

            // Test NVMe Read
            println!("Testing NVMe Read...");
            let mut read_buf = [0u8; 512];
            nvme::nvme_read(1, 0, read_buf.as_mut_ptr(), 1);
            println!("Read completed.");

            // Verify
            if let Ok(s) = core::str::from_utf8(&read_buf[..msg.len()]) {
                println!("Read Data: {}", s);
                if s == "Hello NVMe World!" {
                    println!("NVMe Read/Write Test PASSED!");
                } else {
                    println!("NVMe Read/Write Test FAILED: Content mismatch");
                }
            } else {
                println!("NVMe Read/Write Test FAILED: Invalid UTF-8");
            }
            let write_msg = b"Hello from User Mode via Syscall!";
        let mut write_buf = [0u8; 512];
        for (i, &b) in write_msg.iter().enumerate() {
            write_buf[i] = b;
        }

        let msg = "User: Writing to NVMe...\n";
        syscall(1, msg.as_ptr() as usize, msg.len(), 0, 0, 0, 0);

        // Syscall 8: NVMe Write (nsid=1, lba=10, buf, count=1)
        syscall(8, 1, 10, write_buf.as_mut_ptr() as usize, 1, 0, 0);

        let msg = "User: Reading from NVMe...\n";
        syscall(1, msg.as_ptr() as usize, msg.len(), 0, 0, 0, 0);

        // Test NVMe Read via Syscall
        let mut read_buf = [0u8; 512];
        // Syscall 7: NVMe Read (nsid=1, lba=10, buf, count=1)
        syscall(7, 1, 10, read_buf.as_mut_ptr() as usize, 1, 0, 0);

        let msg = "User: Read complete. Verifying...\n";
        syscall(1, msg.as_ptr() as usize, msg.len(), 0, 0, 0, 0);

        // Verify
        if let Ok(s) = core::str::from_utf8(&read_buf[..write_msg.len()]) {
            if s == "Hello from User Mode via Syscall!" {
                let msg = "User: NVMe Test PASSED!\n";
                syscall(1, msg.as_ptr() as usize, msg.len(), 0, 0, 0, 0);
            } else {
                let msg = "User: NVMe Test FAILED: Content Mismatch\n";
                syscall(1, msg.as_ptr() as usize, msg.len(), 0, 0, 0, 0);

                // Optionally print what we got (not easily doable with simple syscall(1) unless we implement a user-mode formatted print or just dump char by char)
            }
        } else {
            let msg = "User: NVMe Test FAILED: Invalid UTF-8\n";
            syscall(1, msg.as_ptr() as usize, msg.len(), 0, 0, 0, 0);
        }

    }
***/
